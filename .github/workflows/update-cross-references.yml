name: Update Cross References

on:
  workflow_dispatch:
    inputs:
      organization:
        description: The name of the organization the project belongs to
        required: true
      project:
        description: The name or the number of the project
        required: true
      field:
        description: The name of the field
        required: true
      max_references:
        descriptin: The maximum number of references to display on the item(defaults to 10)
        required: false
        default: 1
      updated_after:
        description: Update cross references created after ISO 8601 date(defaults to updating all cross references)
        required: false
        default: null
      html:
        description: Use HTML
        required: false
        default: true
      dry_run:
        description: Is it a dry run? If true, it will NOT add any issues to the project(defaults to false)
        required: false
        default: false
jobs:
  add:
    runs-on: ubuntu-latest
    name: Add Issues to Project
    env:
      GITHUB_TOKEN: ${{ secrets.GALARGH_GITHUB_TOKEN }}
    steps:
      - id: project
        name: Get project
        run: |
          number=null
          id=null
          if [[ "${{ github.event.inputs.project }}" =~ ^[0-9]+$ ]]; then
            number="${{ github.event.inputs.project }}"
            id="$(gh api graphql -f query='{
              organization(login: "${{ github.event.inputs.organization }}"){
                projectNext(number: ${{ github.event.inputs.project }}) {
                  id
                }
              }
            }' --jq '.data.organization.projectNext.id')"
          else
            result="$(gh api graphql -f query='{
              organization(login: "${{ github.event.inputs.organization }}"){
                projectsNext(first: 1, query: "${{ github.event.inputs.project }}") {
                  nodes {
                    id
                    number
                  }
                }
              }
            }')"
            number="$(jq -r '.data.organization.projectNext.number' <<< "$result")"
            id="$(jq -r '.data.organization.projectNext.id' <<< "$result")"
          fi
          echo "::set-output name=id::$id"
          echo "::set-output name=number::$number"
      - id: field
        name: Get field
        run: |
          id=null
          after=null
          has_next_page=true
          while [[ "$id" == null && $has_next_page == true ]]; do
            result="$(gh api graphql -f query='query($after: String){
              organization(login: "${{ github.event.inputs.organization }}"){
                projectNext(number: ${{ steps.project.outputs.number }}) {
                  fields(first: 100, after: $after) {
                    pageInfo{
                      hasNextPage
                      endCursor
                    }
                    nodes {
                      name
                      id
                    }
                  }
                }
              }
            }' -F after="$after")"
            has_next_page=$(jq -r '.data.organization.projectNext.fields.pageInfo.hasNextPage' <<< "$result")
            after=$(jq -r '.data.organization.projectNext.fields.pageInfo.after' <<< "$result")
            id="$(jq -r '[.data.organization.projectNext.fields.nodes[] | select(.name == "${{ github.event.inputs.field }}")] | .[0].id' <<< "$result")"
          done
          if [[ "$id" == null ]]; then
            echo "::error ::Failed to find the field: ${{ github.event.inputs.field }}"
            exit 1
          fi
          echo "::set-output name=id::$id"
      - id: items
        name: Get items
        run: |
          nodes=()
          after=null
          has_next_page=true
          updated_after="$(date --date="${{ github.event.inputs.updated_after }}" +%s)"
          while $has_next_page; do
            result="$(gh api graphql -f query='query($after: String){
              organization(login: "${{ github.event.inputs.organization }}"){
                projectNext(number: ${{ steps.project.outputs.number }}) {
                  items(first: 100, after: $after) {
                    pageInfo{
                      hasNextPage
                      endCursor
                    }
                    nodes {
                      id
                      content {
                        ... on Issue {
                          timelineItems(last: ${{ github.event.inputs.max_references }}, itemTypes: [CROSS_REFERENCED_EVENT]) {
                            totalCount
                            updatedAt
                            nodes {
                              ... on CrossReferencedEvent {
                                source {
                                  ... on UniformResourceLocatable {
                                    url
                                  }
                                  ... on RepositoryNode {
                                    repository {
                                      nameWithOwner
                                    }
                                  }
                                  ... on Issue {
                                    number
                                  }
                                  ... on PullRequest {
                                    number
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }' -F after="$after")"
            has_next_page=$(jq -r '.data.organization.projectNext.items.pageInfo.hasNextPage' <<< "$result")
            after=$(jq -r '.data.organization.projectNext.items.pageInfo.after' <<< "$result")
            for node in $(jq -rc '.data.organization.projectNext.items.nodes[] | select(.content.timelineItems.totalCount > 0)' <<< "$result"); do
              updated_at="$(date --date="$(jq -rc '.content.timelineItems.updatedAt' <<< "$node")" +%s)"
              if [[ "${{ github.event.inputs.updated_after }}" == "" || "$updated_at" -ge "$updated_after" ]]; then
                nodes+=("$node")
              fi
            done
          done
          echo "::set-output name=nodes::$(jq -nc '$ARGS.positional' --args ${nodes[@]})"
      - name: Update cross references
        run: |
          template=null
          ellipsis=null
          if [[ "${{ github.event.inputs.html }}" == 'true' ]]; then
            template='<a href="\(.source.url)" data-hovercard-url="\(.source.url)/hovercard" style="display: block">\(.source.repository.nameWithOwner)#\(.source.number | tostring)</a>'
            ellipsis='<div>…</div>'
          else
            template='\(.source.url)'
            ellipsis='…'
          fi
          for node in $(jq -rc '.[]' <<< "${{ toJson(steps.items.outputs.nodes) }}"); do
            item_id="$(jq -r '.id' <<< "$node")"
            echo "::group::$item_id"
            references=()
            while read reference; do
              if (($(echo "${references[@]} $reference $ellipsis" | wc -c) <= 1024)); then
                references+=("$reference")
              else
                break
              fi
            done <<< "$(jq -r ".content.timelineItems.nodes[] | \"${template//\"/\\\"}\"" <<< "$node" | tac)"
            total_count="$(jq -r '.content.timelineItems.totalCount' <<< "$node")"
            if ((${#references[@]} < total_count)); then
              references+=("$ellipsis")
            fi
            value="${references[@]}"
            echo "Updating cross references for $item_id to $value"
            if [[ '${{ github.event.inputs.dry_run }}' != 'true' ]]; then
              if result="$(gh api graphql -f query='mutation($itemId: ID!, $value: String!){
                  updateProjectNextItemField(input: {
                    projectId: "${{ steps.project.outputs.id }}",
                    itemId: $itemId,
                    fieldId: "${{ steps.field.outputs.id }}",
                    value: $value}) {
                      projectNextItem {
                        id
                      }
                    }
                }' -f itemId="$item_id" -f value="$value")"; then
                echo "Updated cross references for $item_id"
                added_ids+=("$item_id")
              else
                error_message="$(jq '.errors[0].message' <<< "$result")"
                echo "Failed to update cross references for $item_id: $error_message"
                failed_ids+=("$item_id")
              fi
            else
              echo "Skipped because it is a dry run"
            fi
            echo "::endgroup::"
          done
          echo "::set-output name=added::$(jq -nc '$ARGS.positional' --args ${added_ids[@]})"
          echo "::set-output name=failed::$(jq -nc '$ARGS.positional' --args ${failed_ids[@]})"
          if ((${#failed_ids[@]})); then
            echo "::error ::Failed to update cross references for: ${failed_ids[@]}"
            exit 1
          fi
